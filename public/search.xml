<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python操作MySQL——MySQLdb]]></title>
    <url>%2FPython%2FPython%E6%93%8D%E4%BD%9CMySQL%E2%80%94%E2%80%94MySQLdb%2F</url>
    <content type="text"><![CDATA[快速指引MySQLdb 是用于Python链接Mysql数据库的接口，它实现了 Python 数据库 API 规范 V2.0，基于 MySQL C API 上建立的。 MySQLdb安装在命令行中执行： 1$ pip install mysql-python MySQLdb使用MySQLdb Tutorials MySQLdb 导入方式1234#!/usr/bin/python# -*- coding: UTF-8 -*-import MySQLdbimport time MySQLdb 一般流程Python通过MySQLdb操作MySQL数据库的一般过程： 配置数据库参数-&gt;连接数据库-&gt;获取游标对象-&gt;构造SQL语句-&gt;执行SQL语句-&gt;提交事务(write)-&gt;关闭连接 123456789101112131415161718192021222324252627282930313233343536# 1. 配置数据库参数：参数字典conf = &#123; 'host': '127.0.0.1', 'port': 3306, 'user': 'root', 'db': 'didi', 'charset': 'utf8'&#125;# 2. 连接数据库：返回连接对象connconn = MySQLdb.connect(**conf)print conn# 3. 获取游标对象：cursorcursor = conn.cursor(MySQLdb.cursors.DictCursor)print cursor# 4. 构造SQL语句和参数序列:sql_table_str = 'g_team_combine_activity_city_map'sql_fields = ['id', 'activity_id', 'city_id', 'create_time']sql_fields_str = '(&#123;&#125;)'.format(','.join(sql_fields))sql_values_str = '(&#123;&#125;)'.format(','.join(['%s'] * len(sql_fields)))sql_stmt = """INSERT INTO &#123;&#125; &#123;&#125; VALUES &#123;&#125;""".format(sql_table_str, sql_fields_str, sql_values_str)sql_data = [2000,0,0,0]print sql_stmt, sql_data# 5. 执行SQL语句：返回受影响的条数，如果插入失败则回滚事务try: print cursor.execute(sql_stmt, sql_data) conn.commit()except Exception as e: conn.rollback() print e# 6. 关闭连接conn.close() &lt;_mysql.connection open to &apos;127.0.0.1&apos; at 7f87bf2df620&gt; &lt;MySQLdb.cursors.DictCursor object at 0x10c13af90&gt; INSERT INTO g_team_combine_activity_city_map (id,activity_id,city_id,create_time) VALUES (%s,%s,%s,%s) [2000, 0, 0, 0] (1062, &quot;Duplicate entry &apos;2000&apos; for key &apos;PRIMARY&apos;&quot;) 连接DB1234567891011# 端口是int，其他都是字符串# MySQLdb.connect(host=主机, port=端口, user=用户名, passwd=密码, db=数据库, charset='utf8')conf = &#123; 'host': '127.0.0.1', 'port': 3306, 'user': 'root', 'db': 'didi', 'charset': 'utf8'&#125;conn = MySQLdb.connect(**conf) 获取游标12# 传入游标类型：决定了返回记录的类型，字典最常用cursor = conn.cursor(MySQLdb.cursors.DictCursor) 执行SQL原型：cursor.execute(query, args=None) query查询语句和args数据参数需配合使用，总体上有三种使用方式： 完整查询语句+数据参数None：query是一句完整可执行的SQL语句字符串 + args为None； 占位符查询语句+数据参数序列：query中含有占位符%s，args 为一个序列，执行时会先使用args中的值依次替换query中的占位符； 关键字占位符查询语句+数据参数字典：query中含有关键字占位符%(key)s ，args 为一个字典，执行时会先使用args按关键字替换query中的占位符； 后两种方式是将参数作为最终要插入的值，然后代入到查询语句的，而不是先代入再用SQL语句计算其值。 查询执行查询语句123456# 方式一sql1 = 'select * from &#123;0&#125; where &#123;1&#125; &lt; &#123;2&#125;'.format( 'g_team_combine_activity_city_map', 'id', 80)# 返回受影响的记录行数cursor.execute(sql1) 6L 获取查询结果每次获取查询结果，游标会自动后移。 123# 逐条获取记录：返回一个字典，每次获取，游标下移，无数据返回Nonedata1 = cursor.fetchone()print data1 {&apos;city_id&apos;: 1L, &apos;activity_id&apos;: 1L, &apos;create_time&apos;: 1556865052L, &apos;id&apos;: 1L} 123# 获取指定数目的记录：返回一个字典元组，每次读取，游标都会移动data2 = cursor.fetchmany(2)print data2 ({&apos;city_id&apos;: 3L, &apos;activity_id&apos;: 2L, &apos;create_time&apos;: 1556868188L, &apos;id&apos;: 2L}, {&apos;city_id&apos;: 1L, &apos;activity_id&apos;: 45L, &apos;create_time&apos;: 1505969474L, &apos;id&apos;: 5L}) 123# 返回全部结果，字典元组data3 = cursor.fetchall()data3 ({&apos;activity_id&apos;: 71L, &apos;city_id&apos;: 35L, &apos;create_time&apos;: 1506402761L, &apos;id&apos;: 79L},) 插入单条插入‘INSERT INTO table_name (字段1，字段2,…,字段n)’ VALUES (值1，值2，…，值n) 1234567891011121314151617181920212223# 方式一：构造出完整SQL语句，注意这里的unix_timestamp(now())会被SQL执行sql4 = """INSERT INTO g_team_combine_activity_city_map( id, activity_id, city_id, create_time) VALUES(11, 1, 1, unix_timestamp(now()))"""# 方式二：占位符查询语句+数据参数序列，注意这里传递给%s的是最终的结果，因为如果传入SQL函数则不会在SQL中执行sql_stmt1 = """INSERT INTO g_team_combine_activity_city_map( id,activity_id,city_id,create_time) VALUES(%s, %s, %s, %s)"""sql_data1 = [2, 2, 3, time.time()]# 方式三：关键字占位符查询语句+数据参数字典sql_stmt2 = """INSERT INTO g_team_combine_activity_city_map( id,activity_id,city_id,create_time) VALUES(%(id)s, %(activity_id)s, %(city_id)s, %(create_time)s)"""sql_data2 = &#123; 'id': 3, 'activity_id': 5, 'city_id': 7, 'create_time': time.time()&#125; 1234567# 执行SQL语句，提交事务，如果提交失败则回滚try: cursor.execute(sql_stmt2, sql_data2) conn.commit()except Exception as e: conn.rollback() print e 批量插入123456789101112131415161718# 普通方式sql_stmt4 = """INSERT INTO g_team_combine_activity_city_map (id,activity_id,city_id,create_time) VALUES &#123;&#125;""".format(','.join(['(%s)' % ','.join(['%s'] * 4)] * 3))sql_data4 = [(1210,0,0,0), (1211,0,0,0), (1212,0,0,0)]sql_data4 = [tt for t in sql_data4 for tt in t]try: cursor.execute(sql_stmt4, sql_data4) conn.commit()except Exception as e: conn.rollback() print e 12345678910111213141516# executemany，用于多行插入，效率比逐行插入更高sql_stmt3 = """INSERT INTO g_team_combine_activity_city_map (id,activity_id,city_id,create_time) VALUES (%s, %s, %s, %s)"""sql_data3 = [(1205,0,0,0), (1206,0,0,0), (1207,0,0,0)]try: cursor.executemany(sql_stmt3, sql_data3) conn.commit()except Exception as e: conn.rollback() print e 更新操作12345678910111213sql_table_str = 'g_team_combine_activity_city_map'sql_key_dict = &#123;'city_id':999, 'create_time': time.time()&#125;sql_eval_str = ','.join('&#123;&#125; = &#123;&#125;'.format(item[0],item[1]) for item in key_dict.items())sql_cond_str = '&#123;&#125;&gt;&#123;&#125;'.format('id', 1100)sql_stmt4 = """UPDATE &#123;0&#125; SET &#123;1&#125; WHERE &#123;2&#125;""".format(table_str, eval_str, cond_str)try: cursor.execute(sql_stmt4) conn.commit()except Exception as e: conn.rollback() print e 删除操作12345678910sql_table_str = 'g_team_combine_activity_city_map'sql_cond_str = 'id &gt; 1200' sql_stmt5 = """DELETE FROM &#123;&#125; WHERE &#123;&#125;""".format(sql_table_str, sql_cond_str)try: cursor.execute(sql_stmt5) conn.commit()except Exception as e: conn.rollback() print e 创建数据库表1234567891011121314151617181920212223242526sql_stmt6 = """CREATE TABLE `t_data_status` ( `f_id` int(10) NOT NULL AUTO_INCREMENT COMMENT '自增ID', `f_app_id` varchar(32) NOT NULL COMMENT '合作方id', `f_busi_id` varchar(32) NOT NULL DEFAULT 0 COMMENT '内部业务id', `f_src_data_set` varchar(60) NOT NULL DEFAULT '' COMMENT '数据源,即分表名称, 包括基础表和业务基础数据表', `f_des_data_set` varchar(60) NOT NULL DEFAULT '' COMMENT '数据目标,即各个副本表名称, 包括基础表和业务基础数据表', `f_dataset_type_id` int(2) NOT NULL COMMENT '数据源类型dic_dataset_type f_id，字典:医院基础数据，科室基础数据, 医院挂号业务数据等, 通过dic_dataset_type的type知道这条数据是不是基础数据', `f_type` int(1) NOT NULL COMMENT '数据类型，0基础数据, 1业务数据, 冗余字段，便于检索', `f_data_num` int(11) NOT NULL DEFAULT '0' COMMENT '数据总量', `f_relation_id` varchar(32) NOT NULL DEFAULT '' COMMENT '业务生成的unique id，标识基础表和星形表的关联, 例如医院基础数据和医院挂号业务数据两个数据源就需要共用同一个唯一id', `f_status` tinyint NOT NULL COMMENT '状态 1 成功 0 失败', `f_create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '数据方创建时间', `f_version` int(10) NOT NULL DEFAULT 1 COMMENT '数据在当天的版本', `f_deal_status` tinyint NOT NULL DEFAULT '-1' COMMENT '状态 -1 未处理 1 成功 0 失败 状态位2表示处理中..', `f_deal_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '处理数据时的时间', PRIMARY KEY (`f_id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;"""try: cursor.execute(sql_stmt6) conn.commit()except Exception as e: conn.rollback() print e (1050, &quot;Table &apos;t_data_status&apos; already exists&quot;)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Python</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python操作Excel——openpyxl]]></title>
    <url>%2FPython%2FPython%E6%93%8D%E4%BD%9CExcel%E2%80%94%E2%80%94openpyxl%2F</url>
    <content type="text"><![CDATA[快速指引用python读写excel的强大工具：openpyxl。本文只整理了openpyxl中那些使用最频繁的操作，其余的可自行搜索或查看官方文档，或者中文文档。 openpyxl安装1$ pip install openpyxl openpyxl使用1234#!/usr/bin/python# -*- coding: UTF-8 -*-import openpyxl as opxfrom openpyxl.utils import get_column_letter workbook级操作12345678910# 创建一个workbook对象，默认只含有一个sheetwb = opx.Workbook()print wb# 加载已有的Workbook文件，返回一个Workbook对象wb_exist = opx.load_workbook('./learn.xlsx')print wb_exist# 关闭workbook，如果Workbook已打开则关闭，只会影响到read_only和write_only模式wb_exist.close() &lt;openpyxl.workbook.workbook.Workbook object at 0x10966fa50&gt; &lt;openpyxl.workbook.workbook.Workbook object at 0x10968ee90&gt; 12# 保存Workbookwb.save('./5-3.xlsx') Worksheet级操作获取Worksheet对象123456789101112131415# 激活第一个worksheetws = wb.active# 创建新的worksheet，如果表名已被占用则在表名后加123ws1 = wb.create_sheet('Sheet1')ws2 = wb.create_sheet('sheet2')print ws, ws1, ws2# 获取Worksheet对象ws1 = wb['Sheet1']print ws1# 遍历所有worksheetsfor wse in wb.worksheets: print wse.title &lt;Worksheet &quot;Sheet&quot;&gt; &lt;Worksheet &quot;Sheet1&quot;&gt; &lt;Worksheet &quot;sheet2&quot;&gt; &lt;Worksheet &quot;Sheet1&quot;&gt; Sheet Sheet1 sheet2 获取Worksheet对象的属性12345678# 返回所有worksheets的名字print wb.sheetnames# 获取Worksheet的名字print ws.title# 获取Worksheet最大行和最大列，初始时只有一行一列print ws.max_column,ws.max_row [u&apos;Sheet0&apos;, u&apos;Sheet1&apos;, u&apos;sheet2&apos;, u&apos;Sheet0 Copy&apos;] Sheet0 1 1 操作Worksheet12345678910# 更改Worksheet的表名ws.title = 'Sheet0'print ws.title# 更改表名背景颜色ws.sheet_properties.tabColor = "1072BA"# 复制worksheetws_copy = wb.copy_worksheet(ws)print ws_copy Sheet0 &lt;Worksheet &quot;Sheet0 Copy1&quot;&gt; Worksheet行列操作123# 在Worksheet的max_row后面追加一行数据，序列默认从第一列添加，不足则补Nonews.append([1,2])tuple(ws.values) ((1, 2),) 123# 也可传入字典，key对应了列ws.append(&#123;1:3, 'C': 5&#125;)tuple(ws.values) ((1, 2, None), (3, None, 5)) Worksheet插入/删除行或列123# 在第3行前面插入行，如果参数超出了当前范围则什么也不做ws.insert_rows(1)tuple(ws.values) ((None, None, None), (1, 2, None), (3, None, 5)) 12ws.delete_rows(idx=3,amount=1)tuple(ws.values) ((None, None, None), (1, 2, None)) Cell级操作获取Cell对象1234567891011121314151617181920# 获取单个Cellcell_a1 = ws['A1']cell_a1 = ws.cell(row=1, column=1)print cell_a1# 当一个worksheet在内存中被创建时，它不包含任何Cell，只有当Cell被首次访问时才被创建for r in range(3): for c in range(2): ws.cell(row=r+1, column=c+1)# 获取单行Cell、获取单列Cell，返回一个单元格对象组成的元组print ws[1], len(ws[1])print ws['A'], len(ws['A'])# 获取多行多列print '前三列', ws['A':'C']print '前两行：', ws[1:2]# 获取一个区域print 'A1:C2：',ws['A1':'C2'] &lt;Cell u&apos;Sheet0&apos;.A1&gt; (&lt;Cell u&apos;Sheet0&apos;.A1&gt;, &lt;Cell u&apos;Sheet0&apos;.B1&gt;, &lt;Cell u&apos;Sheet0&apos;.C1&gt;) 3 (&lt;Cell u&apos;Sheet0&apos;.A1&gt;, &lt;Cell u&apos;Sheet0&apos;.A2&gt;, &lt;Cell u&apos;Sheet0&apos;.A3&gt;) 3 前三列 ((&lt;Cell u&apos;Sheet0&apos;.A1&gt;, &lt;Cell u&apos;Sheet0&apos;.A2&gt;, &lt;Cell u&apos;Sheet0&apos;.A3&gt;), (&lt;Cell u&apos;Sheet0&apos;.B1&gt;, &lt;Cell u&apos;Sheet0&apos;.B2&gt;, &lt;Cell u&apos;Sheet0&apos;.B3&gt;), (&lt;Cell u&apos;Sheet0&apos;.C1&gt;, &lt;Cell u&apos;Sheet0&apos;.C2&gt;, &lt;Cell u&apos;Sheet0&apos;.C3&gt;)) 前两行： ((&lt;Cell u&apos;Sheet0&apos;.A1&gt;, &lt;Cell u&apos;Sheet0&apos;.B1&gt;, &lt;Cell u&apos;Sheet0&apos;.C1&gt;), (&lt;Cell u&apos;Sheet0&apos;.A2&gt;, &lt;Cell u&apos;Sheet0&apos;.B2&gt;, &lt;Cell u&apos;Sheet0&apos;.C2&gt;)) A1:C2： ((&lt;Cell u&apos;Sheet0&apos;.A1&gt;, &lt;Cell u&apos;Sheet0&apos;.B1&gt;, &lt;Cell u&apos;Sheet0&apos;.C1&gt;), (&lt;Cell u&apos;Sheet0&apos;.A2&gt;, &lt;Cell u&apos;Sheet0&apos;.B2&gt;, &lt;Cell u&apos;Sheet0&apos;.C2&gt;)) 遍历行/列/单元格对象遍历用 ws.iter_rows 和 ws.iter_cols 就够了！！ 123# 按行列号遍历每一行，带min max参数时不受已激活范围的影响for row in ws.iter_rows(min_row=1,max_row=2,min_col=1,max_col=3): print row (&lt;Cell u&apos;Sheet0&apos;.A1&gt;, &lt;Cell u&apos;Sheet0&apos;.B1&gt;, &lt;Cell u&apos;Sheet0&apos;.C1&gt;) (&lt;Cell u&apos;Sheet0&apos;.A2&gt;, &lt;Cell u&apos;Sheet0&apos;.B2&gt;, &lt;Cell u&apos;Sheet0&apos;.C2&gt;) 123# 遍历每一列，不带min max参数时，只返回激活范围内的单元格for col in ws.iter_cols(): print col (&lt;Cell u&apos;Sheet0&apos;.A1&gt;, &lt;Cell u&apos;Sheet0&apos;.A2&gt;, &lt;Cell u&apos;Sheet0&apos;.A3&gt;) (&lt;Cell u&apos;Sheet0&apos;.B1&gt;, &lt;Cell u&apos;Sheet0&apos;.B2&gt;, &lt;Cell u&apos;Sheet0&apos;.B3&gt;) (&lt;Cell u&apos;Sheet0&apos;.C1&gt;, &lt;Cell u&apos;Sheet0&apos;.C2&gt;, &lt;Cell u&apos;Sheet0&apos;.C3&gt;) 1234# 行优先遍历每个单元格，ws.iter_rows()和ws.rows效果相同，但前者可自定义参数for row in ws.iter_rows(): for cell in row: print cell &lt;Cell u&apos;Sheet0&apos;.A1&gt; &lt;Cell u&apos;Sheet0&apos;.B1&gt; &lt;Cell u&apos;Sheet0&apos;.C1&gt; &lt;Cell u&apos;Sheet0&apos;.A2&gt; &lt;Cell u&apos;Sheet0&apos;.B2&gt; &lt;Cell u&apos;Sheet0&apos;.C2&gt; &lt;Cell u&apos;Sheet0&apos;.A3&gt; &lt;Cell u&apos;Sheet0&apos;.B3&gt; &lt;Cell u&apos;Sheet0&apos;.C3&gt; 1234# 遍历区域for row in ws['a1:c2']: for cell in row: print cell &lt;Cell u&apos;Sheet0&apos;.A1&gt; &lt;Cell u&apos;Sheet0&apos;.B1&gt; &lt;Cell u&apos;Sheet0&apos;.C1&gt; &lt;Cell u&apos;Sheet0&apos;.A2&gt; &lt;Cell u&apos;Sheet0&apos;.B2&gt; &lt;Cell u&apos;Sheet0&apos;.C2&gt; 123# 遍历值for row in ws.iter_rows(min_row=1,max_col=2,values_only=True): print row (None, None) (1, 2) (None, None) 获取单元格的属性12cell = ws['A1']print cell.value None 修改Cell的属性修改单元格的值123456789# 修改单元格的值ws['A1'] = 0print ws['A1'].value# 修改一个区域的值，需要逐个赋值for r in ws['a1':'c3']: for c in r: c.value = 3print tuple(ws.values) 0 ((3, 3, 3), (3, 3, 3), (3, 3, 3)) 修改单元格的格式12345678910111213141516171819202122232425262728293031323334353637383940单元格的默认属性:&gt;&gt;&gt; font = Font(name=&apos;Calibri&apos;,... size=11,... bold=False,... italic=False,... vertAlign=None,... underline=&apos;none&apos;,... strike=False,... color=&apos;FF000000&apos;)&gt;&gt;&gt; fill = PatternFill(fill_type=None,... start_color=&apos;FFFFFFFF&apos;,... end_color=&apos;FF000000&apos;)&gt;&gt;&gt; border = Border(left=Side(border_style=None,... color=&apos;FF000000&apos;),... right=Side(border_style=None,... color=&apos;FF000000&apos;),... top=Side(border_style=None,... color=&apos;FF000000&apos;),... bottom=Side(border_style=None,... color=&apos;FF000000&apos;),... diagonal=Side(border_style=None,... color=&apos;FF000000&apos;),... diagonal_direction=0,... outline=Side(border_style=None,... color=&apos;FF000000&apos;),... vertical=Side(border_style=None,... color=&apos;FF000000&apos;),... horizontal=Side(border_style=None,... color=&apos;FF000000&apos;)... )&gt;&gt;&gt; alignment=Alignment(horizontal=&apos;general&apos;,... vertical=&apos;bottom&apos;,... text_rotation=0,... wrap_text=False,... shrink_to_fit=False,... indent=0)&gt;&gt;&gt; number_format = &apos;General&apos;&gt;&gt;&gt; protection = Protection(locked=True,... hidden=False) 1from openpyxl.styles import PatternFill, Border, Side, Alignment, Protection, Font 123456789101112131415161718# 以修改单元格的字体为例font = Font(name='Calibri', size=16, bold=False, italic=False, vertAlign=None, underline='none', strike=False, color='FF000000')alignment=Alignment(horizontal='left', vertical='center', text_rotation=0, wrap_text=False, shrink_to_fit=False, indent=0)ws['a1'] = 9999ws['a1'].font = fontws['a1'].alignment = alignment 1wb.save('./learn_openpyxl.xlsx') 改进模式有时，您需要打开或写入非常大的XLSX文件，而OpenPYXL中的常见例程将无法处理该负载。幸运的是，有两种模式使您能够以（接近）恒定的内存消耗来读写无限量的数据。 只读模式12wb_read = opx.load_workbook(filename='./learn_openpyxl.xlsx', read_only=True)wb_read &lt;openpyxl.workbook.workbook.Workbook at 0x1096f4110&gt; 12ws_read = wb_read.activeprint ws_read.max_row,ws_read.max_column 3 3 12for row in ws_read.iter_rows(values_only=True): print row (9999L, 3L, 3L) (3L, 3L, 3L) (3L, 3L, 3L) 12wb_read.close()wb_read &lt;openpyxl.workbook.workbook.Workbook at 0x1096f4110&gt; 只写模式 与普通工作簿不同，新创建的只写工作簿不包含任何工作表；必须使用 create_sheet() 方法。 在只写工作簿中，只能使用 append() . 不能在任意位置用 cell() 或 iter_rows() . 它能够导出无限量的数据（甚至超过了Excel的实际处理能力），同时将内存使用量保持在10MB以下。 只写工作簿只能保存一次。之后，每次试图将工作簿或append（）保存到现有工作表时，都会引发 openpyxl.utils.exceptions.WorkbookAlreadySaved 例外。 在添加单元格之前，必须创建实际单元格数据之前出现在文件中的所有内容，因为在此之前必须将其写入文件。例如， freeze_panes 应在添加单元格之前设置。 123# load_workbook本地读取的Excel没有只写权限wb_write = opx.Workbook(write_only=True)wb_write &lt;openpyxl.workbook.workbook.Workbook at 0x1096cba10&gt; 1234# 只写模式的Workbook创建后，没有sheet，需要手动创建print wb_write.worksheetsws_write = wb_write.create_sheet()print ws_write [] &lt;WriteOnlyWorksheet &quot;Sheet&quot;&gt; 12# 只写模式的worksheet没有cell属性，也不能通过索引来获取单元格ws_write.cell --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-39-5164431d4a6c&gt; in &lt;module&gt;() 1 # 只写模式的worksheet没有cell属性，也不能通过索引来获取单元格 ----&gt; 2 ws_write.cell AttributeError: &apos;WriteOnlyWorksheet&apos; object has no attribute &apos;cell&apos; 1ws_write.append([1,2,3]) 123456789# 如果希望为单元格添加格式或注释，可以使用WriteOnlyCellfrom openpyxl.cell import WriteOnlyCellfrom openpyxl.comments import Commentfrom openpyxl.styles import Fontcell = WriteOnlyCell(ws, value="hello world")cell.font = Font(name='Courier', size=36)cell.comment = Comment(text="A comment", author="Author's Name")ws.append([cell, 3.14, None]) 1wb_write.save('./write_only.xlsx')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《大秦帝国之裂变》语录]]></title>
    <url>%2Funcategorized%2F%E5%A4%A7%E7%A7%A6%E5%B8%9D%E5%9B%BD%E4%B9%8B%E8%A3%82%E5%8F%98%2F</url>
    <content type="text"><![CDATA[第一集：少梁之战秦兵：赳赳老秦，复我河山。血不流干，死不休战。 第二集：秦军撤兵少梁之战，秦献公身中狼毒箭，魏国丞相公孙痤被俘，秦军撤兵。 第三集：献公传位献公召见公子虔 献公：跟公父说实话，你想不想做国君？ 公子虔：公父让我做，我便做，公父不让我做，我便不做。 献公：好，为父没有看错你，铮铮铁骨，定国柱石。 公子虔：公父说过，秦国疲弱，祸在内斗，惟有一心，方能强国。 献公：老大啊，你说实话，为父有没有把你和渠梁分过嫡庶？ 公子虔：公父何出此言啊，儿臣周岁丧母，国后娘抱儿养儿，历尽了艰辛万苦，爱儿如同亲生，养儿胜于亲娘，此恩是天高地厚，儿臣纵是禽兽也九死不能报万一，儿臣又怎会生出嫡庶异心之分。 献公：你娘是你娘啊。。。 公子虔：公父待儿，倚重之心天地可鉴，庶出疏离之感，儿臣从未有过。 献公：好，好，老大，为父那就放开说话了。老大，你说，假如你是农夫，是工匠，或者是个军士，你看谁做国君更好？ 公子虔：渠梁更合适。儿臣绝无虚言。 献公：老大，为父还是要你立誓明心啊。 公子虔：公父是信不过儿臣吗？ 献公：不，老大，不是不信任你，实在是国家公器不能寄予一言，即使是骨肉兄弟，也得是公心为先 公子虔：（自断手指中。。。） 献公：老大，老大，我看看，哎呀。。。你呀。。。 献公召见渠梁 献公：渠梁啊，公父有话跟你说，不要分心，公父的路要走完了，我决定立你为太子，即刻继国君之位。 渠梁：公父，这。。。 献公：听我说完！这是老大的血誓，他若有二心，你就可以公诸朝野，人人得以诛之。 渠梁：公父，我与大哥素来同心同德，为何让大哥如此折磨自己？ 献公：渠梁啊，千万要记住，同德易，同心难，大德大节，求同就更难，历来公室内乱，哪个不是骨肉相残？赢虔，他是内明之人，你要倚重他，血誓，只防万一。 渠梁：公父放心，公父教诲渠梁铭记在心，如果食言，死不得入赢氏太庙。 第四集：秦国释放公孙痤渠梁阻止荧玉杀公孙痤 渠梁：小妹，你可以不认我这个哥哥，但你不能不认我这个国君。 荧玉：你为何不让我杀公叔老贼？ 渠梁：私仇滥杀，乱国乱局。 荧玉：君仇国恨自古一体，何谓私仇？ 渠梁：无视国家存亡，惟泄一己怨恨，就是私仇。 荧玉：得先君之位忘先君之仇，这才是天地难容！ 渠梁：公器不存私念，公父若在，也会如此。左庶长，公叔痤不能杀。 嬴虔：左庶长？我是你大哥！ 渠梁：事涉国家，没有大哥，只有君臣。 嬴虔：老秦人同仇敌忾，我看哪个国君敢护仇？ 渠梁：父仇为私，不能公报！娘，大哥，小妹，大臣将士们，渠梁少入军旅，和父老兄弟并肩血战沙场，脚下踩过万千老秦人的尸骨，哪个不是做梦都想着复仇啊，杀一个俘虏，就能证明我们老秦人的血性吗？今日杀了公孙痤，只能解一时之恨，然而必然引起山东六国集体攻秦，到时候邦国灭亡，尸骨成山，谁来复仇啊，复个鸟！说到底，只有保住国家，保住百姓，保住将士，秦国才能复仇，才能翻身，才能雪耻！ 卫鞅救师求见公子虔公子虔：什么事那么重要，别绕弯子，说吧。卫鞅：原本申明非秦公不言，念公子虔是秦国栋梁，新君兄长，说也无妨。公子虔：直说，实说。卫鞅：在下入秦，一非官派，二非私托，只为一事，救回老丞相以全师生之交。公子虔：就凭你啊。卫鞅：卫鞅救师，也救秦国。公子虔：哈哈哈。。。魏人救秦？笑话。卫鞅：上将军未免浅见，在下明言，魏国朝野，庞涓力主灭秦，而丞相公叔图谋称霸，二人势同水火。庞涓奇袭骊山，就是要夺回公叔明正典刑，一举剪除政敌，从而全力灭秦，今奇袭未成，庞涓自然退而求其次，希望借秦人之手杀死我师，若秦国当真如此，无异于助了庞涓一臂之力，加重了自己的危机处境。眼下，唯有一策，即可救我师，又可救秦国。公子虔：说下去。卫鞅：这一策便是，秦国放人、割地、求和。使魏国一时无攻秦口实，日后再做图谋，如此，两全，否则秦国危在旦夕。公子虔：卖国求私，还大言侃侃，天下一奇啊。卫鞅：在下并非魏人，更非魏臣，何谈卖国。公子虔：带入大营。。。 渠梁谈和公孙痤公孙痤：你说，老秦公死了？既然如此，老夫的人头归你了，何时开刀？渠梁：老丞相差矣，渠梁不是要杀你，而是来放你。公孙痤：哈哈哈。。。小子，你敢嘲弄老夫，士可杀，不可辱渠梁：渠梁怎敢侮辱前辈，我诚意放老丞相回归安邑，想当时秦魏两国激战多年，生灵涂炭，死伤无数，渠梁新任国君，只图秦国庶民安居耕牧，并不想两国纠缠交恶，素知老丞相深明大义，嬴渠梁欲与老丞相共谋两国休战歇兵，并无它意。公孙痤：秦公不记杀父之仇？渠梁：父仇为私，和战为公。嬴渠梁若非真心，愿受上天惩罚。公孙痤：好，老夫信你。只是这疆界，不知秦公如何打算？渠梁：以石门大战之前为定。公孙痤：河西高原，秦东地带，函谷关都给魏国？渠梁：嗯。公孙痤：两国邦交作何说法？渠梁：秦国承认魏国霸主地位。公孙痤：纳贡，称臣？渠梁：不称臣，不纳贡。公孙痤：再让一步，会更稳妥一些。渠梁：老丞相，凡事都有底线，秦国穷困，无贡可纳，秦人硬骨，不能折腰。公孙痤：秦公大明！渠梁：二十年后我会夺回来的。公孙痤：共有此心，老夫拭目以待，只是这缓兵之计太过明显渠梁：老丞相，秦国虽穷，却是尚武善战之邦，若魏国执意灭秦，老秦人必将拼死血战，魏国纵然灭秦，也将在惨胜之后元气大伤，那时，魏国必成众矢之的，非但保不住霸主地位，反而被五大强国瓜分，如果魏王不明此理，秦国宁肯血战到底。休息三五日之后，渠梁派出特使护送老丞相返回安邑，不言俘获，只当做魏王议和特使对待，行吗？公孙痤：哎，老夫阅人无数，秦公气量胸怀，数年之后必令天下刮目相看。渠梁：渠梁浅陋，哪敢当此褒奖。公孙痤：可惜老夫来日不多，不能与你并世争雄了。 第五集：说服魏王谈和卫鞅支持公孙痤争霸方略公孙痤：卫鞅，你到酒肆去了？卫鞅：老师，族人有望解禁。公孙痤：酒肆消息你也信？荒唐卫鞅：哈哈。。。断事不在消息源头，在自家评判。公孙痤：算了，不说在这些了，鞅啊，总算是有惊无险。卫鞅：不，险关还未过，庞涓以一统天下为终身大志，铁了心要拿秦国开刀，魏王未必不为所动。公孙痤：庞涓、公子卬都想杀老夫。卫鞅：公子卬不足为虑，争功夺权罢了，庞涓才是真正的大患。公孙痤：这一统天下也是大魏功业所在，老夫若是为了保住性命而反对，公心何在？卫鞅：老师差矣，一统天下如果可行，卫鞅也不会帮老师与庞涓对峙。公孙痤：你说一统天下不可行？卫鞅：时势未到，眼下不可行。公孙痤：为何?卫鞅：天下无一心，七国无独强，未来之势未见分晓，冒然灭国定会招致灾祸。公孙痤：你是说，还是老夫的争霸方略，适合魏国？卫鞅：正是。卫鞅：备车！ 公孙痤说服魏王谈和魏王：那老丞相你说，让本人怎么接受秦国那几块鸡零狗碎？公孙痤：如何对秦，首在长策！魏王：先说办法，再讲长策！公孙痤：老臣的办法分两步走。魏王：第一步。公孙痤：与秦罢兵，接纳割地，河西秦东数十县，再加上函谷关天险，绝非鸡零狗碎。魏王：第二步。公孙痤：待秦地完全划入魏国，等到时机成熟再变灭秦为分秦。魏王：灭秦分秦有何区别？公孙痤：灭秦，魏国独吞；分秦，六国分吞。魏王：那如此一来，我既无后顾之忧，又可稳坐天下霸主了。公孙痤：正是魏王：果然姜是老的辣！ 魏王庞涓密谋分秦策略魏王：本王在庙堂上的运筹，上将军明白吗？庞涓：我王一番指点，臣恍然醒悟魏王：这就对了，你今天想谋兵灭秦固然是上策，但是现在到达嘴边的这块肥肉不能让它滑了，一纸休兵盟书，不费一兵一卒，我大魏便可稳稳占了秦国东部最肥美的土地城池，到哪去找这等好事去？实咬一口当然胜过虚啃三日，治国之道尽在此矣！庞涓：不过，我王，臣以为，先食言于秦国，再食言于五国，只怕有失道义。魏王：道义？现在天下大争，谁讲道义，讲道义干什么？我今天就是要咬秦国这块肥肉，然后啃秦国这块骨头，谁敢奈我何？不服，不服就等你先强大了再说；你弱，你就没有说话的资格，就只能等着做别人砧板上的鱼肉，明白吗？什么叫邦交？下刀之前的动作才叫邦交。庞涓：臣以为，还是打出来的地盘更实在。魏王：打归打，谈归谈嘛，两手并用才能得天下，明白吗？六国分秦，即刻交你放手去做，彻底灭秦之日就是你上将军首功之时。庞涓：臣遵命。 卫鞅推测老师无恙公叔痤：庞涓、公子卬都想杀了老夫取而代之，魏王耳根子又软。卫鞅：魏王醉心权谋，喜好均衡朝局，鞅以为，老师无恙。魏王派庞涓为全权特使，正密谋六国分秦。公叔痤：魏王，你的心也太急了，盟约刚立，就谋分秦，你让老夫有何颜立足于天下，让大魏又有何面目立于天下?卫鞅：更重要的，魏国死盯弱小秦国，丧失了中原扩张的最佳时机。 第六集：六国指地分秦楚王：这商於、武关归我大楚了。韩王：那崤函、关中一带就归我大韩。赵王：陇西、北地全部归赵了。燕王：河西、河套归我大燕。齐王：齐秦相隔太远，本王不争秦地，然则我灭他国，列国不得插手。庞涓：哼，如此分秦，盟主国是一无所得了?众王：魏国已吞肥肉，再分居心何在？天下三王，不能只听魏王的。庞涓：五君之意，是不认我魏国盟主了？众王：庞涓，魏王国书原说，公平分秦，今日公平何在？庞涓：公平？以本上将军谋划，根本不需要六国分秦。 第七集：]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>大秦帝国</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Github Pages 博客搭建教程（五）：问题解答]]></title>
    <url>%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2FHexo-Github-Pages-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94%2F</url>
    <content type="text"><![CDATA[百度和Google收录使用 GitHub + Hexo 搭建的博客，默认只能你自己能看到，别人是无法通过百度、谷歌等搜索引擎搜索到的: 可以手动将自己的博客站点提交给百度、谷歌的搜索引擎，这样就可以通过百度或谷歌搜索到自己的博客内容了： 百度收录验证站点登录百度搜索资源平台&gt;用户中心&gt;站点管理&gt;添加网站，输入网站域名，选择站点属性，到第三步“验证网站”： 有三种不同的验证方式：文件验证、HTML标签验证、CNAME验证。这里我们选择文件验证，下载验证文件到本地，放置在 themes/next/source目录下，执行生成和部署命令： 1$ hexo g -d 然后点击完成验证即可： 添加站点地图站点地图（sitemap）可以告诉搜索引擎网站上有哪些可供抓取的网页，以便搜索引擎可以更加智能地抓取网站。 安装百度和谷歌站点地图生成插件：cd 到你的站点目录，执行以下命令 12$ npm install hexo-generator-baidu-sitemap --save$ npm install hexo-generator-sitemap --save 修改 url：修改站点配置文件 _config.yml 中的 url 参数: 1234url: http://jonzzs.cn # 修改成你博客的首页地址root: /permalink: :year/:month/:day/:title/permalink_defaults: 修改配置文件：修改站点配置文件 _config.yml，添加以下内容： 12345# 自动生成sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 生成和部署：执行生成和部署命令后，进入public目录，你会发现里面有 sitemap.xml 和baidusitemap.xml 两个文件，这就是生成的站点地图，前者用来提交给谷歌，后者用来提交给百度 1$ hexo g -d 自动推送站点地图：在百度资源搜索平台，找到链接提交，这里我们可以看到有两种提交方式，自动提交和手动提交，自动提交又分为主动推送、自动推送和sitemap，自动推送配置最简单，将主题配置文件下的 baidu_push 设置为 true： 12# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: true 百度收录网站到此配置结束，只需要等待百度收录，这个过程会比较久。 谷歌收录验证站点登陆Google网站站长 &gt; 进入Search Console &gt; 添加资源： 我们选择 HTML 文件上传的方式验证，下载验证文件到本地，放置在 themes/next/source目录下，执行生成和部署命令： 1$ hexo g -d 部署完成之后，进行验证即可： 添加站点地图安装插件、修改配置文件在上述百度收录过程已经做过了，现在只需要点击前往站点资源页面 &gt; 点击站点地图，添加新的站点地图 sitemap.xml： 即可完成谷歌收录网站，只需要等待谷歌收录，这个过程会比较久。 参考 Hexo博客提交百度和Google收录 百度资源平台 Google网站站长]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Github Pages 博客搭建教程（四）：域名绑定]]></title>
    <url>%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2FHexo%20%2B%20Github%20Pages%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[购买域名Github Pages 的默认域名是 &lt;your_name&gt;.github.io， 如果想将默认域名修改为个人域名，首先你要拥有一个自己的域名，如果还没有，可在以下几个网站购买： 阿里云域名注册 腾讯云域名注册 GoDaddy 绑定域名如果你已经购买了域名，绑定已有域名需要分别在“域名解析服务商”和 “Github” 两边进行设置。 域名解析配置将域名和其他域名进行绑定，让你可以通过不同域名访问同一个网站。因为我是在腾讯云上买的域名，就用腾讯云的域名解析服务了。 腾讯云控制台 &gt; 云解析 &gt; 解析 &gt; 修改 &gt; 添加记录： 主机记录：@ 表直接解析主域名； 记录类型：CNAME 将域名指向另一个域名，再由另一个域名提供 ip ； 线路类型：选默认； 记录值：填写一个域名，即你原有的Github Pages 访问地址； TTL：缓存默认时间，默认600s； Github 设置进入你的仓库 &lt;your_name&gt;.github.io ，点击 Settings ，在 Github Pages设置项中将 Custom domain 设置为你的个人域名： 这时会在你的仓库目录下自动生成一个 CNME 文件，里面存放着你的个人域名。 上面的方式有一个问题，那就是你每次部署站点时 CNME都会自动消失，还需要你手动再设置一遍，所以为了方便，可以直接将 CNME 存放在 source 目录下，每次部署就会一同上传了。 完成以上设置之后，可以在浏览器中输入你自己的域名即可访问你的博客了： 参考 Github pages 绑定个人域名 腾讯云COS]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Github Pages 博客搭建教程（三）：文章写作]]></title>
    <url>%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2FHexo%20%2B%20Github%20Pages%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%96%87%E7%AB%A0%E5%86%99%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[写作流程使用 HEXO 写作博客的一般流程： 创建文章：通过 hexo new [layout] &lt;title&gt; 创建一篇新的文章； 编辑文章：通过本地 Markdown 编辑器完成博客内容的写作； 发布文章：将博客发布到你的服务器； 创建文章你可以通过下列命令来创建一篇新文章： 1$ hexo new [layout] &lt;title&gt; 布局Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹： 布局 翻译 路径 post 发表 source/_post page 页面 source draft 草稿 source/_drafts 草稿草稿（draft）默认不会显示在页面中，但你可以通过以下三种方式中的任意一种来预览草稿： 发布草稿：执行 hexo publish [layout] &lt;title&gt; 可以将草稿从source/_drafts 文件夹移动到 source/_posts 文件夹； 在执行时加上 --draft 参数； 把 render_drafts 参数设为 true ：这将在页面中显示全部草稿，一般不这么用； 模板在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： 1$ hexo new photo &quot;My Gallery&quot; 在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，以下是您可以在模版中使用的变量： 变量 描述 layout 布局 title 标题 date 文件建立日期 文件名Hexo 默认以标题做为文件名称，但您可编辑站点配置文件中的 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章： 变量 描述 :title 标题（小写，空格将会被替换为短杠） :year 建立的年份，比如， 2015 :month 建立的月份（有前导零），比如， 04 :i_month 建立的月份（无前导零），比如， 4 :day 建立的日期（有前导零），比如， 07 :i_day 建立的日期（无前导零），比如， 7 编辑文章HEXO 文章编写采用 Markdown 语法进行写作，一级标题太大，建议从二级标题开始。 Front-matterFront-matter 是指文章头部以 --- 分隔的区域，用于指定个别文件的变量。以下是预先定义的参数，您可在模板中使用这些参数值并加以利用： 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 只有文章支持分类和标签，分类具有顺序性和层次性，以下是文章分类和标签的一个例子： 12345678# 文章在Diary/Life下categories: - Diary - Life# 文章有两个标签PS3、Gamestags: - PS3 - Games 一个文章可以有多个标签，多个分类，用中括号就可以达到并列效果: 1234# 文章同时在Diary类别和Life类别下categories: - [Diary] - [Life] 插入图片俗话说“一图胜千言”，但在博客中插入图片一直是件让人头疼的事，在博客中插入图片大体有两种方式： 作为本地文件引用：首先将图片同代码文件一起上传至站点服务器，然后以相对路径形式引用；HEXO 提供了三种图片引用方式： 将图片放在 source/images 文件夹中。然后通过类似于 ![](/images/image.jpg) 的方法访问它们； 将 _config.yml 文件中的 post_asset_folder 选项设为 true ，Hexo将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹，这个资源文件夹将会有与这个 markdown 文件一样的名字，将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们； 以上两种方式会导致图片无法在主页或归档页显示的问题，为此， HEXO) 推出了使用标签插件来引用图片的方式，但这种方式的可移植性不强，也不推荐； 作为外链引用：首先将图片上传至图床（储存图片的服务器）生成外链，然后以外链形式引用；这种方式可大大简化图片管理，节约宝贵的服务器资源，加快图片加载速度，推荐使用； 发布文章发布文章很简单，只需要经过“生成”和“部署”两步就行了： 12$ hexo g$ hexo d 你也可以通过以下一行命令来完成“生成”和“部署”两个过程： 1$ hexo g -d 如果你希望在正式发布前，先在本地查看发布后的实际效果并进行调试，也可以在“生成”步骤之后，通过以下命令打开本地服务器，您的网站会在 http://localhost:4000 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。 123$ hexo s# 或者进入调试模式$ hexo s --debug 如果你的文章符合以下两种情况之一，那么以上过程将不会对你的文章进行处理，你的文章也就不会被发布出去： 文章存放在草稿文件夹 source/_drafts 中； 文章名称被添加到站点配置文件中的 skip_render； 在实际写作中，更常用的写作流程如下： 123456789# 1. 创新草稿$ hexo n draft &lt;title&gt;# 2. 编辑文章# 3. 发布文章$ hexo publish &lt;title&gt;# 4. 渲染文章$ hexo g# 5. 部署文章$ hexo d 写作工具“工欲善其事，必先利其器”，好的写作工具能够让博客写作变得更简单、更有趣。 Mweb 编辑器Mweb 是 Mac上一款非常好用的 Markdown 写作、记笔记、静态博客生成软件，极力推荐。 Mweb 有以下一些优点: 简洁的外观； 丰富的快捷键； 丰富的扩展语法； 轻松编辑表格； 图片的快速插入与统一管理； 图片自动上传图床功能； 可设置图片居左/中/右； 一键生成/上传博客； 支持各种导出格式； 图床国内外有众多图床可供选择，图床可分为两种： 公共图床：利用公共服务的图片上传接口，来提供图片外链的服务，比如 Imgur 图床、微博图床、SM.MS 图床等等； 私有图床：利用各大云服务商提供的存储空间或者自己在 VPS 上使用开源软件来搭建图床，如七牛云、又拍云、阿里云 OSS、腾讯云 COS、自建图床工具 Lychee，此外 Github 仓库也可作为少量图片的图床使用，但不推荐这么做； 关于各种图床的优劣可以参考文章盘点一下免费好用的图床，公共图床不可控也不安全、私有图床大多需要网站备案，在尝试了多个图床之后，我最后选择了腾讯云 COS 。 腾讯 COS 配置通过腾讯云&gt;控制台&gt;对象存储&gt;存储同列表&gt;创建存储桶，如下： 有两个关键的配置不能忽略： 设置访问权限：将访问权限应设置为公有读私有写； 设置防盗链：开启之后即使其他人获取到链接也无法访问相应图片； PicGo图片上传工具PicGo 是一款开源跨平台的免费图片上传工具以及图床相册管理软件，它能帮你快速地将图片上传到微博、又拍云、阿里云 OSS、腾讯云 COS、七牛、GitHub、sm.ms、Imgur 等常见的免费图床网站或云存储服务上，并自动复制图片的链接到剪贴板里，使用上非常高效便捷。 关于 PicGo 的下载安装和配置使用的详细过程请参照PicGo指南。PicGo 支持剪切板上传和拖拽上传两种方式： 参考 腾讯对象存储 PicGo指南]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Github Pages 博客搭建教程（二）：主题定制]]></title>
    <url>%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2FHexo%20%2B%20Github%20Pages%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%B8%BB%E9%A2%98%E5%AE%9A%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下，然后修改下配置文件即可。 这里推荐 Next 主题，该主题简洁大方美观，集成度高，定制性强，官方文档完备，十分适合新手使用。下面以 NexT 主题为例，介绍主题切换、配置方法。 NexT 主题安装下载主题NexT 主题下载有两种方式： 官网下载：前往 NexT 版本发布页面，找到 Source code 点击下载，下载后解压到站点目录的 themes 目录下； git clone：直接将源码克隆到站点目录的 themes 目录下； 12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题打开站点配置文件，找到 theme 字段，并将其值更改为 next 即可； 1theme: next 验证主题启动本地站点服务器，使用浏览器访问 http://localhost:4000 当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题，这是 NexT 默认的 Scheme —— Muse。 NexT 主题定制主题风格千变万化且各有所好，建议在充分参考 NexT 官方文档和他人博客风格的前提下，选择最适合自己的风格，总的原则是：简洁、实用。下面列举了 NexT 主题常见的定制方法，如果有更多定制需求，可自行百度。 说明： 配置文件：“站点配置文件”是指站点目录下的 _config.yml 文件，“主题配置文件”是指NexT 主题文件下的 _config.yml 文件。 配置生效：如果修改了站点配置文件，可能需要先清理静态文件，再重新生成静态文件，最后重新启动服务器，才会生效，如果还不行，可能需要多次生成部署； 123$ hexo clean$ hexo g$ hexo s 整体定制选择 SchemeNexT 提供了多种不同的外观风格 Scheme，几乎所有的配置都可以在 Scheme 之间共用，可通过更改 主题配置文件，搜索 Scheme 关键字，将你需用启用的 scheme 前面注释 # 去除即可。 将默认的 Muse 主题注释掉，取消 Mist 的注释 12345678# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes# scheme: Musescheme: Mist# scheme: Pisces# scheme: Gemini 查看新 Scheme 的效果: 设置语言观察以上截图，发现首页标签为英文，编辑站点配置文件，将 language 设置成你所需要的语言（简体中文对应zh-Hans）: 1language: zh-Hans 设置字体Hexo 默认字体大小为 14px，如果感觉字体太小，可打开 \themes\next\source\css\ _variables\base.styl文件，将 font-size-base 改成16px即可，如下所示： 12// Font size$font-size-base = 16px 更改网页图标 FaviconNexT 提供了默认的网页图标，可通过以下步骤进行自定义设置： 制作 Favicon 图标：可以先在 EasyIcon 中找到一张你所喜欢的 ico 图标，然后通过比特虫在线生成两张ico图标（大小分别为16x16和32x32），将图标放在 /themes/next/source/images ； 修改主题配置文件： 12345favicon: small: /images/feather-16x16.ico medium: /images/feather-32x32.ico apple_touch_icon: /images/apple-touch-icon-feather.png safari_pinned_tab: /images/apple-touch-icon-feather.png 修改后的实际效果： 隐藏网页底部 powered By Hexo在主题配置文件中，修改如下配置： 12345678# Hexo link (Powered by Hexo). powered: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: true 修改网页头部图片 修改格式文件：打开 hexo\themes\next\source\css\_schemes\Mist\_header.styl，将第一行 background: 后的内容改为如下形式： 1.header &#123; background: url(&apos;https://likeitea-1257692904.cos.ap-guangzhou.myqcloud.com/liketea_blog/top_pic.jpg&apos;); &#125; 显示效果：并不简洁美观，建议采用默认背景 添加 README.md 文件如果希望在项目中添加 README.md 文件，又不想对该文件进行渲染，可在 Hexo 目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件 _config.yml，将 skip_render 参数的值设置为 1skip_render: README.md 保存退出即可，再次使用 hexo d 命令部署博客的时候就不会再渲染 README.md 这个文件了。 侧边栏定制侧边栏出现位置和时机默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。可以通过修改主题配置文件中的 sidebar 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。 设置侧边栏位置： 123# left 靠左，right靠右sidebar: position: left 设置侧边栏显示时机： 123# post是默认行为，在文章页显示；另外几个选项是always、hide、removesidebar: display: post 设置站点信息 设置头像：编辑 主题配置文件，修改字段 avatar，值设置成头像的链接地址，可以是完整URI，也可以是本地文件路径（站点目录下的 source/images 或者主题目录下的 source/uploads）。 1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /images/avatar.png 设置作者昵称：编辑 站点配置文件， 设置 author 为你的昵称； 设置站点描述：编辑 站点配置文件， 设置 description 字段为你的站点描述。站点描述可以是你喜欢的一句签名； 建站时间：编辑 主题配置文件，新增字段 since:年份； 修改作者头像并旋转如果希望将作者头像修改为圆形，并且实现鼠标悬浮于图片上时图片旋转的效果，可按照以下步骤进行修改： 修改代码：打开\themes\next\source\css\_common\components\sidebar\sidebar-author.styl，在里面添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 效果如图： 设置RSSNexT 中 RSS 有三个设置选项，满足特定的使用场景，更改 主题配置文件：设定 rss 字段的值： false：禁用 RSS，不在页面上显示 RSS 连接。 留空：使用 Hexo 生成的 Feed 链接，你可以需要先安装 hexo-generator-feed 插件。 1$ npm install hexo-generator-feed 具体的链接地址：适用于已经烧制过 Feed 的情形。 重启服务器，侧边栏效果如图： 侧边栏社交链接侧边栏社交链接的修改包括链接和图标两部分，打开主题配置文件： 123456789101112131415# 社交链接，键值格式是“显示文本: 链接地址 || 图标名”social: GitHub: https://github.com/your-user-name Twitter: https://twitter.com/your-user-name 微博: http://weibo.com/your-user-name 豆瓣: http://douban.com/people/your-user-name 知乎: http://www.zhihu.com/people/your-user-name # 社交图标，键值格式是“显示文本: Font Awesome 图标名称”，enable 选项用于控制是否显示图标social_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter 微博: weibo 侧边友情链接友情链接可用于提供一些关联网站地址，或者推荐文章。 编辑 主题配置文件：友情链接包含两个部分，① 友情链接名称、图标；② 每个友情链接的名称、地址； 12345678910# Blog rolls# 友情链接本身的名字和图标links_icon: planelinks_title: 友情链接# 友情链接显示格式：竖、横links_layout: block#links_layout: inline# 友情链接名称、地址links: likew: https://likew.bitcron.com 侧边栏最终效果： 首页定制设置菜单菜单配置包括三个部分： 菜单项：名称和链接，名称指在内部文件中使用的变量名； 菜单项文本：菜单在页面上显示的文字； 菜单项图标：NexT 主题默认集成了识别Font Awesome图标的方法，只需要在里面找到想要图标的名称，去掉前缀icon- 就可以拿过来直接使用，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题； 编辑主题配置文件，修改以下内容： 设定菜单项和菜单项图标：menu下的设置项格式为菜单项名称: 链接路径 || 菜单项图标； 12345678menu: home: / || home about: /about/ || user tags: /tags || tags categories: /categories/ || th archives: /archives/ || archive schedule: /schedule/ || calendar sitemap: /sitemap.xml || sitemap 设置菜单项文本：如果要修改菜单项文本，可打开 NexT 主题目录下的 languages/{language}.yml（{language} 为你所使用的语言），进行编辑修改； 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 something: 有料 保留你需要的菜单项后，实际效果如图： 添加标签页面新建“标签”页面，并在菜单中显示“标签”链接，在标签页展示站点所有标签，如果所有文章都没有标签则标签页将是空的。 配置方法： 新建页面：在终端窗口下，定位到 Hexo 站点目录下，使用 hexo new page 新建一个页面，命名为 tags ； 123456789# 切换到站点目录$ cd your-hexo-site# 新建tags页面，会在source目录下自动生成tags文件夹$ hexo new page tags# tags目录下包含index文件夹和index.md文件$ tree ./source/tags ./source/tags ├── index └── index.md 设置页面类型：编辑刚才新建的index.md文件，将页面类型设置为tags， 主题将自动为这个页面显示标签云，一般标签页不显示评论； 123456---title: 标签date: 2019-03-12 16:15:10type: &quot;tags&quot;comments: false--- 修改菜单：在菜单中添加链接，编辑主题配置文件，添加 tags 到 menu 中，如下: 1234menu: home: / archives: /archives tags: /tags 设置文章标签：在文章 front-matter 添加 tags 字段，可设置文章的标签： 12345678---title: 测试标签页date: 2019-03-12 16:34:39tags: - 标签1 - 标签2 - 标签3--- 实际效果：启动本地站点服务器，使用浏览器访问 http://localhost:4000 ，标签页如图所示。 添加分类页面“分类”和“标签”都可以用来对文章进行管理，区别在于分类多级、有序而标签同级、无序。分类是一种更加精细的文件管理方式，可以按照主题结构树来管理文章，标签则是一种平面化的管理方式，适合于快速定位到一些关键词。 新建页面：在站点目录下创建分类页面 12$ cd your-hexo-site$ hexo new page categories 设置页面类型：打开 categories/index.md 文件，修改页面类型，一般分类页面不显示评论： 12345title: 分类date: 2014-12-22 12:39:04type: &quot;categories&quot;comments: false--- 修改菜单：打开主题配置文件，修改 menu 下的categories 为 /categories 1234menu: home: / archives: /archives categories: /categories 实际效果：分类页面显示分类树结构，但不会显示具体分类下的文章。点击具体的分类类别，可显示该类别下的所有文章： 首页文章以摘要形式显示 修改主题配置文件：打开主题配置文件，找到如下位置，修改 1234# 其中length代表显示摘要的截取字符长度auto_excerpt: enable: true length: 150 修改后的效果如图： 设置首页文章显示篇数 安装插件： 123npm install --save hexo-generator-indexnpm install --save hexo-generator-archivenpm install --save hexo-generator-tag 修改站点配置文件：在 站点配置文件 中，添加如下内容，其中 per_page 字段是你希望设定的显示篇数。index，archive 及 tag 开头分表代表主页，归档页面和标签页面 123456789101112index_generator: path: &apos;&apos; per_page: 10 order_by: -date # 反之，date时间早的在前面archive_generator: per_page: 20 yearly: true monthly: truetag_generator: per_page: 10 文章页定制设置代码高亮NexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 normal 主题，可选的值有 normal，night， night blue， night bright， night eighties： 更改 highlight_theme 字段，将其值设定成你所喜爱的高亮主题（默认的就挺好），例如： 12345# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal 修改文章底部带 # 号的标签修改模板 /themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;，效果如图： 文章顶部显示更新时间123456# Post meta display settings 文章显示信息post_meta: item_text: true created_at: true updated_at: true categories: true 开启打赏功能NexT 支持微信打赏和支付宝打赏，只需要在 主题配置文件 中填入微信或支付宝收款二维码图片地址（绝对地址从source目录起）即可开启该功能。 123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /path/to/wechat-reward-imagealipay: /path/to/alipay-reward-image 实际效果: 设置动画效果设置加载动画NexT 默认开启动画效果，效果使用 JavaScript 编写，因此需要等待 JavaScript 脚本完全加载完毕后才会显示内容。 如果您比较在乎速度，可以将 use_motion 设置为 false 来关闭加载动画； 添加顶部加载条修改主题配置文件 _config.yml 将 pace设为 true 就行了，你还可以换不同样式的加载条，如下图： 1234567891011121314151617181920212223# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter# 跳跳球#pace-theme-bounce#pace-theme-barber-shop# 原子转#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar# 进度条#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar# pace-theme-mac-osx# 简约式#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-minimal 实际效果： 点击出现红心效果 添加 js 文件：在 hexo\themes\next\source\js\src\ 目录下新增文件 love.js，文件内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546!function(e, t, a) &#123; function n() &#123; c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"), o(), r() &#125; function r() &#123; for (var e = 0; e &lt; d.length; e++) d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = "left:" + d[e].x + "px;top:" + d[e].y + "px;opacity:" + d[e].alpha + ";transform:scale(" + d[e].scale + "," + d[e].scale + ") rotate(45deg);background:" + d[e].color + ";z-index:99999"); requestAnimationFrame(r) &#125; function o() &#123; var t = "function" == typeof e.onclick &amp;&amp; e.onclick; e.onclick = function(e) &#123; t &amp;&amp; t(), i(e) &#125; &#125; function i(e) &#123; var a = t.createElement("div"); a.className = "heart", d.push(&#123; el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: s() &#125;), t.body.appendChild(a) &#125; function c(e) &#123; var a = t.createElement("style"); a.type = "text/css"; try &#123; a.appendChild(t.createTextNode(e)) &#125; catch (t) &#123; a.styleSheet.cssText = e &#125; t.getElementsByTagName("head")[0].appendChild(a) &#125; function s() &#123; return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")" &#125; var d = []; e.requestAnimationFrame = function() &#123; return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function(e) &#123; setTimeout(e, 1e3 / 60) &#125; &#125;(), n()&#125;(window, document); 修改配置：在文件 hexo\themes\next\layout\_layout.swig 底部的 &lt;/body&gt; 标签上一行增加： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 实际效果: 设置背景动画编辑 主题配置文件， 搜索 canvas_nest 或 three_waves，根据您的需求设置值为 true 或者 false 即可（会干扰读者注意力，建议关闭）： 12345678# Canvas-nestcanvas_nest: true# three_waves# three_waves: true# canvas_lines# canvas_lines: true# canvas_sphere# canvas_sphere: True Canvas-nest 的实际效果： 第三方插件使用静态站点拥有一定的局限性，因此我们需要借助于第三方服务来扩展站点的功能。 以下是 NexT 目前支持的第三方服务，你可以根据你的需求集成一些功能进来。 添加站内搜索配置方法如下： 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1npm install hexo-generator-searchdb --save 编辑站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true 站点搜索效果： 添加评论区NexT 支持多款评论系统： 多说：已挂； 畅言：需要备案； Disqus：已墙； valine：LeanCloud提供的后端云服务，可用于统计网址访问数据，分为开发版和商用版，只需要注册生成应用App ID和App Key即可使用； 来必力：来自韩国，使用邮箱注册； Gitment：一款基于 GitHub Issues 的评论系统，支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持，尤为适合各种基于GitHub Pages的静态博客或项目页面； DISQUS编辑 主题配置文件， 将 disqus 下的 enable 设定为 true，同时提供您的 shortname，count 用于指定是否显示评论数量： 1234disqus: enable: false shortname: count: true 需要注册 disqus 账号后才可参与评论，效果如下： gitmentGitment 使用 GitHub Issues 作为评论系统，在接入 Gitment 前，需要获得 GitHub 的授权，获得相应的客户端id和客户端私钥，以备站点使用。gitment 的配置方法: 创建 oAuth App ：github首页 &gt; settings &gt; Developer settings &gt; OAuth Apps &gt; New oAuth App，Homepage URL 和 Authorization callback URL 都写上你的 github 博客首页地址（如果绑定了个人域名，则写完整的新域名地址），比如 https://liketea.xyz，点击 Register application即可完成注册，生成 Client ID 和 Client Secret； 修改 主题配置文件 ：最重要的就是 github_repo，可以是你托管博客静态文件的仓库，也可以是新仓库，注意是仓库名称而不是仓库地址； 12345678910111213gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: true # Hide &apos;Powered by ...&apos; on footer, and more language: zh-CN # Force language, or auto switch by theme github_user: liketea # MUST HAVE, Your Github ID github_repo: liketea.github.io # MUST HAVE, The repo you use to store Gitment comments client_id: a52dc...0f3b156f7c # MUST HAVE, Github client id for the Gitment client_secret: 2307d156a...a8495b1b68a3a3ae # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 重新部署：通过 hexo g -d 重新部署站点，进入一篇文章的评论区； 登入授权：点击登入，对评论区进行授权； 解决无法登陆的问题：如果点击授权之后，评论区一直在转圈圈，但是登录不进去 打开浏览器的调试功能，发现报了个错误~点击后面的网址，一路点击高级、继续前往 然后你会发现依旧访问不了，不过不用理会，此时gitment已经可以登录啦~ 最后初始化评论：每一篇文章都需要进行初始化才能开始评论，目前还没有较好的一键初始化方法； 来必力以上评论系统，要么已经挂掉了、要么被墙了、要么各种BUG、要么原始界面奇丑，通过各种尝试发现还是来必力最好用： 注册登陆 来必力 获取你的 LiveRe UID：点击安装免费的city版本，安装成功后点击代码管理，复制其中的 data-uid 字段 编辑主题配置文件，填写 livere_uid：将复制的 data-uid 12# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: &quot;MTAyMC80M...Tc0NQ==&quot; 实际效果：来必力支持使用已有社交网站(SNS)账号登录 添加统计分析统计文章阅读次数LeanCloud 可以统计单篇文章阅读次数，配置过程如下: 注册 LeanCloud：完成邮箱激活，进入控制台页面； 创建应用：创建一个新应用，名称无所谓，点击应用进入； 创建名称为Counter的Class：名称必须为Counter； 查看应用 key：在所创建的应用的设置-&gt;应用key 中查看 app_id 和app_key ； 修改主题配置文件： 1234leancloud_visitors: enable: true app_id: m135LmdEWo9GrD-gzGzoHsz app_key: CWheAQhgeEYEa1nDYn 重新部署 Hexo 博客：重新部署后便可以在博客主页以及每篇文章中显示阅读次数，如图所示 说明： 为了安全，设置网站的安全域名：设置——安全中心——Web安全域名； 记录文章访问量的唯一标识符是文章的发布日期以及文章的标题，因此请确保这两个数值组合的唯一性，如果你更改了这两个数值，会造成文章阅读数值的清零重计； 添加文章阅读量排行榜 新建排行页面：在根目录路径下，执行 hexo new page &quot;rank&quot;； 编辑主题配置文件：加上菜单 rank 和它的 icon: 12menu: rank: /rank/ || signal 在语言文件中加上菜单 rank，以中文为例，在 /themes/next/languages/zh_Hans.yml 中添加： 1234567891011menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 rank: 排行榜 编辑~/source/top/index.md：必须将里面的里面的 app_id 和 app_key 替换为你的 LeanCloud 在主题配置文件中的值；必须替换里面博客的链接；1000 是显示文章的数量，其它可以自己看情况更改； 12345678910111213141516171819202122232425262728---title: 排行榜comments: false---&lt;div id="hot"&gt;&lt;/div&gt;&lt;script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"&gt;&lt;/script&gt;&lt;script&gt;AV.initialize("app_id", "app_key");&lt;/script&gt;&lt;script type="text/javascript"&gt; var time=0 var title="" var url="" var query = new AV.Query('Counter'); query.notEqualTo('id',0); query.descending('time'); query.limit(1000); query.find().then(function (todo) &#123; for (var i=0;i&lt;1000;i++)&#123; var result=todo[i].attributes; time=result.time; title=result.title; url=result.url; var content="&lt;p&gt;"+"&lt;font color='#1C1C1C'&gt;"+"【文章热度:"+time+"℃】"+"&lt;/font&gt;"+"&lt;a href='"+"https://liketea.github.io/"+url+"'&gt;"+title+"&lt;/a&gt;"+"&lt;/p&gt;"; document.getElementById("hot").innerHTML+=content &#125; &#125;, function (error) &#123; console.log("error"); &#125;);&lt;/script&gt; 实际效果： 统计站点访问次数NexT 集成了“不蒜子服务”，可以统计站点 uv（全站访客人次）、pv（全站点击次数）和单页面 pv，配置更加方便。 编辑 主题配置文件 中的 busuanzi_count 配置项：当 enable: true 时，代表开启全局开关，若site_uv 、site_pv 、page_pv 的值均为 false 时，不蒜子仅作记录而不会在页面上显示 123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; site_uv_footer: 人次 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; site_pv_footer: 次 # custom pv span for one page only page_pv: false page_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; page_pv_footer: 次 禁用单页面pv：不蒜子的 单页面pv 默认显示在文章标题下边，但是却不会在站点主页显示，因此我们还是选择用 LeanCloud 来显示 单页面pv 而使用不蒜子来显示 站点uv, pv ，实际效果如图所示： 如果发现页面中的统计数据都不显示： 那是因为不蒜子统计的js文件找不到了，官方给出了相应的方法，即只需要更改 next 主题下的不蒜子 插件的 js 引用链接即可。进入 hexo 博客项目的 themes 目录下，在 next 主题目录中的 layout/_third-party/analytics/ 下找到 busuanzi-counter.swig 文件，将: 1&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 替换为如下代码既可： 12&lt;script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 统计文章字数 安装插件:在根目录下安装 hexo-wordcount，运行： 1$ npm install hexo-wordcount --save 修改主题配置文件：然后在主题的配置文件中，配置如下 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true # 是否显示项目文字 wordcount: true # 是否显示统计字数 min2read: true # 是否显示阅读时长（分钟） totalcount: true # 是否显示总字数 separated_meta: true 实际效果: 添加分享服务jiathis 已关闭服务，我采用了 needmoreshare2，其配置过程如下： 编辑主题配置文件中的 needmoreshare2 ：将enable 设置为 true： 123456789101112131415161718needmoreshare2: enable: true # 底部提交分享按钮 postbottom: enable: false options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook # 左侧悬浮分享按钮 float: enable: true options: iconStyle: box boxForm: horizontal position: topRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook 实际效果如图，包含了微博、微信、QQ、豆瓣等众多渠道： 以上只有微信点击无法分享，只需修改themes\next\source\lib\needsharebutton\needsharebutton.js： 1234# 把var imgSrc = &quot;https://api.qinco.me/api/qr?size=400&amp;content=&quot; + encodeURIComponent(myoptions.url);# 改为var imgSrc = &quot;http://api.qrserver.com/v1/create-qr-code/?size=150x150&amp;data=&quot; + encodeURIComponent(myoptions.url); 该分享方式为生成博客的二维码，手机扫码之后即可分享: 为博客添加其他功能文章加密访问 修改代码：打开主题文件夹/layout/_partials/head.swig在首句后面插入以下代码： 12345678910&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; if (prompt(&apos;请输入文章密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;密码错误&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 为文章设置密码：在需要加密的文章里加进password: 你要设的密码，像这样： 1234567---title: 13date: 2019-03-14 21:06:14tags:categories:password: 123456--- 实际效果：点击文章，需要输入正确密码 文章置顶 修改 hero-generator-index 插件：把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为： 12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加 top 值：数值越大文章越靠前 1234567---title: 13date: 2017-05-22 22:45:48tags: categories: top: 100--- 添加网易云音乐我将网易云音乐播放器放在了侧边栏，想要听的朋友可以手动点击播放，配置方法如下： 生成外链播放器：在网页版网易云音乐中搜索我们想要插入的音乐或歌单，然后点击“生成外链播放器” 设置ifame插件参数：选择 310x90，取消勾选自动播放 插入代码：将网易云音乐插件生成的 HDML 代码插入到文件 layout\_macro\sidebar.swig中 &lt;/aside&gt;上一行，类似于以下代码 1234&lt;div id="music163player"&gt; &lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="//music.163.com/outchain/player?type=2&amp;id=38358214&amp;auto=0&amp;height=66"&gt; &lt;/iframe&gt;&lt;/div&gt; 实际效果：可操作播放、暂停，上/下一曲，如果尺寸是 310x413 则可以展开播放列表 参考 hexo的next主题个性化教程:打造炫酷网站 NexT官方文档 NexT主题个性化设置]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Github Pages 博客搭建教程（一）：博客搭建]]></title>
    <url>%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2FHexo%20%2B%20Github%20Pages%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[前言随着移动互联网的到来，使用电脑订阅资讯的时代一去不复返，博客时代芳华已逝，但内容创作永不过时。这里我想先谈一下自己对于个人博客的看法。 为什么要写博客： 践行“费曼技巧”：与假想听众一起学习是最佳的学习方式； 建立“云知识库”：大脑的记忆总是模糊、有限而易逝的，博客便是整理过的记忆，清晰、持久而又便于回忆； 为什么要搭建个人博客： 公共博客平台不可控或收费； 收获自主权和归属感； 为什么选择 Hexo + GitPages 搭建个人博客： 轻量：没有麻烦的配置，使用标记语 Markdown ，无需自己搭建服务器； 免费：免费托管 Github 仓库，有 1G 免费空间； 通用：是目前比较流行的方案，社区活跃，不断创新； 准备工作博客搭建过程主要涉及 Hexo 和 Github Pages 两个工具，在开始搭建博客前，首先要完成以下准备工作： 注册 Github 账号：按指示完成注册即可； 创建两个 Github 仓库：一个仓库名为&lt;username&gt;.github.io，用于托管博客的静态文件（public文件夹）、生成 Github Pages 展示页面；另一个仓库名为&lt;username&gt;.github.source 用于文章备份，可兼作图床（source 文件夹）； 本地安装git：先在本地安装 homebrew 软件包管理工具，再通过 brew install git 安装 git 工具，通过git version 查看 git 是否成功安装； 123456# 安装homebrew$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;# 安装git$ brew install git$ git versiongit version 2.15.0 配置git公钥：Git 服务器都会选择使用 SSH 公钥来进行授权，配置方法也很简单，在本地通过 ssh-keygen 生成密钥对之后，将./.ssh/id_rsa.pub 中的公钥添加到github账号SSH key； 安装node.js：brew install node安装，node -v检查是否安装成功； 123$ brew install node$ node -vv8.4.0 安装Hexo：在安装好 git 和 node.js 之后就可以使用npm install -g hexo-cli 安装 hexo 了，可通过 hexo version 查看hexo 版本信息； 1234$ npm install -g hexo-cli$ hexo versionhexo-cli: 1.1.0os: Darwin 18.0.0 darwin x64 本系列教程基于操作系统 macOS Mojave，windows 或Linux 也可作参考。 搭建博客利用 Hexo 和 Github Pages 搭建博客的基本原理：首先通过 Hexo 将 Markdown 文件渲染生成静态网页，再将静态站点托管到 Github 仓库，利用 Github Pages 服务以网页形式显示仓库内容。 创建站点成功安装 Hexo 后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件： 1234# 在目标文件夹中创建新站点，Hexo会从hexo-starter代码库clone代码到目标文件夹$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 创建站点后的文件目录： 12345678.├── node_modules ├── scaffolds ├── source ├── themes ├── _config.yml ├── package-lock.json └── package.json node_modules：node依赖包； scaffolds：模版文件夹，用户可自定义markdown模板，默认包含了以下三种模板 page：页面模板； post：文章模板； draft：草稿模板； source：资源文件夹，存放用户所有资源； themes：主题文件夹； _config.yml：在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置，称作站点配置文件；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项，称作主题配置文件； 生成静态文件使用 Hexo 生成静态文件快速而且简单： 1$ hexo generate Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入：1$ hexo generate --watch 完成后部署，让 Hexo 在生成完毕后自动部署网站，以下四个命令的作用是相同的： 1234$ hexo generate --deploy$ hexo deploy --generate$ hexo g -d$ hexo d -g 调试站点Hexo 3.0 把服务器独立成了个别模块，您必须先安装 hexo-server 才能使用： 1$ npm install hexo-server --save 安装完成后，输入以下命令以启动服务器： 1$ hexo server 在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器，您的网站会在 http://localhost:4000 下启动，效果如下： 如果希望服务器只处理 public 文件夹内的文件，而不会处理文件变动，可以在静态模式下启动服务器，此模式通常用于生产环境（production mode）下： 1$ hexo server -s 如果希望以调试模式启动服务器： 1$ hexo server --debug 如果您想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，可以在执行时使用 -p 选项指定其他端口，如下： 1$ hexo server -p 5000 部署站点将我们的站点部署到github上，需要三个步骤： 安装 hexo-deployer-git：该命令需在站点文件目录下执行； 1$ npm install hexo-deployer-git --save 修改配置：修改配置文件_config.yml中的 deploy 配置； 12345678910111213# type表示服务器类型，repo表示仓库地址，branch和message可省略deploy: type: git repo: &lt;repository url&gt; # https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io branch: [branch] # published message: [message]# 您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployerdeploy: type: git repo: type: heroku repo: Hexo 一键部署：如果出现错误请先检查以上各步骤是否正确设置； 1$ hexo deploy 站点成功部署后，站点目录下的 public 文件夹会被同步到相应的 github 仓库中，可以在仓库的 Settings 下找到 GitHub Pages 网页的地址（默认为 &lt;github用户名&gt;.github.io），网页默认效果如下： 至此，一个简易的个人博客就搭建完成了。但是距离一个简洁大方、美观实用的博客系统还有很多地方需要优化。 Hexo 常用命令现将 Hexo 常用命令整理如下，更详细的说明参见Hexo官方文档-指令： 命令 简写 说明 hexo init [folder] 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站 hexo new [layout] &lt;title&gt; hexo n [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来 hexo generate hexo g 生成静态文件 -d, --deploy文件生成后立即部署网站-w, --watch监视文件变动 hexo publish [layout] &lt;filename&gt; 发表草稿，将草稿移动至_post文件夹 hexo server hexo s 启动服务器 -p, --port重设端口；-s, --static只使用静态文件；-l, --log启动日记记录，使用覆盖记录格式； hexo deploy hexo d 部署网站，-g, --generate部署之前预先生成静态文件 hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令 hexo list 列出网站资料，Available types: page, post, route, tag, category hexo version 显示Hexo版本 hexo --draft 显示 source/_drafts 文件夹中的草稿文章 hexo migrate &lt;type&gt; 从其他博客系统 迁移内容 参考 Hexo官方文档 GitHub+Hexo 搭建个人网站详细教程 Hexo+Github Pages+Next博客搭建 mac环境下搭建hexo+github pages+next个人博客]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[费曼技巧：以教促学]]></title>
    <url>%2Funcategorized%2F%E8%B4%B9%E6%9B%BC%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[中学时，常常喜欢和别人讨论一些深奥的物理或哲学问题，这些在大多数人看来枯燥乏味的内容，在我却是甘之如饴。但要找到一位志同道合或是愿意倾听、一同讨论的人是很难的，为了维系本就为数不多的几位“听众”，在每次读书时，我总会无意识地假想自己该如何把当前所学讲给他们听，设想他们可能会提出怎样的质疑，我又该如何应答，通过这种方式，逼迫自己反复斟酌逻辑、简化表达，用尽可能简单的语言向他们解释清楚最深奥的道理……到了本科，对哲学的兴趣愈加浓厚，读了从古希腊到康德时期的很多经典著作，将所读所想整理成了两册笔记，笔记本便成了我的忠实听众……后来读了计算机方面的研究生，计算机领域知识浩如烟海且日新月异，好在整个行业奉行开源共享的精神，我也慢慢学会了将自己的学习笔记和生活感悟搬到博客上来…… 以上便是我在学生生涯的不同时期所采用的三种自学方法：讨论、笔记、博客。虽然不同时期所凭借的学习媒介不同，但却有着一脉相承的共同原则： 与“假想听众”一同学习，反复斟酌逻辑、简化表达，直至听众完全听懂，便是真正学会。 直至近日在网上看到了对“费曼技巧”的解释，才发现自己一直默默践行的学习方法原来早就有了名字，至于费曼本人是否提出过“费曼技巧”，网上以讹传讹，无从考证，当然名称本就无关紧要，重要的是其内涵是否指向一种行之有效的学习方法。 只有教会别人，才算真正学会 著名物理学家马克斯·普朗克因为量子物理学研究而获得了诺贝尔奖，他在德国各地演讲。每次他的司机都会无意聆听讲座，不久后他就将演讲摸索的一清二楚了，于是他提议，在下个城市演讲时可以进行角色互换。于是在下个演讲中，普朗克同意并伪装成司机坐在观众群中。司机站在他的位置进行演讲……演讲取得了圆满成功。全场响起热烈的欢呼声和掌声！司机能像普朗克本人一样绘声绘色地进行演讲。但是，一位教授询问有关这个报告中的内容。司机当然不知道如何回答这个问题！尽管如此，他还是保持冷静，并且回答道：“我很惊讶，您提出这么简单的问题，即使我的司机也知道，我会让他回答这个问题”。 你认为这个故事的主旨是什么呢？是的，司机的头脑非常敏捷。但这不是重点，这里描述了两种不同的知识： 真正的“普朗克知识”：普朗克能真正了解报告中内容的深层意思（knowing something），并能向一个原本不了解报告内容的人解释明白； 表面的“司机知识”：司机只是掌握了关于专业名称和关系方面的知识（knowing the name of something），他能在恰当的时刻运用这些句子，正确地在上下文中使用专业术语，并能准确无误地呈现内容，但涉及对内容的理解方面……他却什么都不懂； 表面的“司机知识”只能用于“鹦鹉学舌”，只有具备真正的“普朗克知识”才叫“真正学会”。不幸的是，大多数人都在专注于表面的“司机知识”而不自知，那么检验是否“真正学会”的标准又是什么呢？ 说他知道自己的想法但却无法表达的人, 通常并不知道他自己的想法。 – Mortimer Adler如果你不能解释它，就说明你还不够理解它。– Albert Einstein 也就是说：只有能教会别人，才说明掌握了真正的“普朗克知识”，才算真正学会了。 只有教会别人，才能真正学会这里我无意玩弄文字游戏，只怪汉语博大精深……“教会”和“学会”在上一句中表结果，意指能否教会别人是验证自己是否真正学会的标准；在本句中表过程，意指只有通过教会别人的这个过程，自己才能真正学会。 one can only learn by teaching. – Wheeler 费曼技巧是一种“以教促学”的学习方法：在学习某个主题时，假想自己要把它教给一个对其毫无所知的人，思考应该如何表达，在思考过程中不断发现、弥补漏洞，组织、简化表达，以致不断加深对主题的理解，当把他教会的时候自己也就真正学会了。 费曼技巧的四个步骤人们一般将费曼技巧总结为四个步骤： 确定主题：选择一个你想了解的概念，写在纸上； 教给孩子：在白纸上写下你对这个概念的解释，就好像你正在教导一位新接触这个概念的学生一样。当你这样做的时候，你会更清楚地意识到关于这个概念你理解了多少，以及是否还存在理解不清的地方； 发现漏洞：无论何时你感觉卡壳了，都要回到原始的学习资料并重新学习让你感到卡壳的那部分，直到你领会得足够顺畅，顺畅到可以在纸上解释这个部分为止； 组织简化：最终的目的，是用你自己的语言，而不是学习资料中的语言来解释概念。如果你的解释很冗长或者令人迷惑，那就说明你对概念的理解可能并没有你自己想象得那么顺畅； 费曼技巧流程图： 费曼技巧的评价在我看来，践行“费曼技巧”有以下好处: 激发学习动力：“假想听众”的存在会产生学习的责任感和使命感； 自检学习效果：人易自欺欺人，“假想听众”可以更客观地检验学习的真实效果； 完善知识体系：发现、弥补漏洞的过程就是建立知识体系的过程； 训练表达能力：“说不出来”在于没有形成自己的一套逻辑体系和语言体系； 参考 费曼技巧：学习任何东西的最佳方式 费曼技巧视频 号称终极快速学习法的费曼技巧，究竟是什么样的学习方法？]]></content>
  </entry>
</search>
